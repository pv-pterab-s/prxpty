return if not process.env.DBG?

log = require 'log'
M = (s) -> console.log s; s
E = (s) -> console.error s; s

export cat-buffers = (buffer-a, buffer-b) ->
  new-length = buffer-a.length + buffer-b.length
  Buffer.concat [buffer-a, buffer-b], new-length

export split-buffer = (buffer, value) ->
  splits = []

  last-transition = 0
  prev-in-value-region = (buffer[0] is value)

  for i from 1 to buffer.length - 1 by 1
    in-value-region = (buffer[i] is value)
    switch
      when prev-in-value-region and not in-value-region
        in-value-region = (buffer[i] is value)
        last-transition = i
      when not prev-in-value-region and in-value-region
        splits.push buffer.slice last-transition, i
    prev-in-value-region = (buffer[i] is value)
  if last-transition < buffer.length - 1
    splits.push buffer.slice last-transition, buffer.length

  splits

export find-last-value = (buffer, value) ->
  for i from buffer.length - 1 to 0 by -1
    if buffer[i] is value
      return i
  undefined


buffer = new Buffer(0)
export get-buffer = -> buffer

export consume-logs-buffer = (incoming-buffer) ->
  buffer := cat-buffers buffer, incoming-buffer        # collect signals
  last-newline = find-last-value buffer, 10
  return [] if not last-newline?                       # do nothing if no
                                                       # completed msgs

  msgs-end = last-newline
  complete-msgs-buffer = buffer.slice 0, msgs-end      # all completed msgs
  buffer := buffer.slice msgs-end + 1, buffer.length   # save partial msg

  split-buffer complete-msgs-buffer, 10                # separate msgs


standard-stdin-on = process.stdin.on
process.stdin.on = (event, cb) ~>
  if event is 'data'
    standard-stdin-on.call process.stdin, 'data', (d) ->
      msgs = consume-logs-buffer d
      msgs.map (raw) ->
        msg = log.log2msg raw.toString!
        cb msg.msg
  else
    standard-stdin-on event, cb
